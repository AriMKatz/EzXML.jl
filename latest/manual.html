<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · EzXML.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>EzXML.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="manual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Data-types-1">Data types</a></li><li><a class="toctext" href="#DOM-interfaces-1">DOM interfaces</a></li><li><a class="toctext" href="#Constructing-documents-1">Constructing documents</a></li><li><a class="toctext" href="#Streaming-interfaces-1">Streaming interfaces</a></li></ul></li><li><a class="toctext" href="references.html">References</a></li><li><a class="toctext" href="devnotes.html">Developer Notes</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="manual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/bicycle1885/EzXML.jl/tree/67777a7cdb42f686d7f76b1143bc2cb103eef85f/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><p>This page is dedicated to those who are new to EzXML.jl. It is recommended to read this page before reading other pages to grasp the concepts of the package first. Once you have read it, <a href="references.html">the references page</a> would be a better place to find necessary functions. <a href="devnotes.html">The developer notes page</a> is for developers and most users do not need to read it.</p><h2><a class="nav-anchor" id="Data-types-1" href="#Data-types-1">Data types</a></h2><p>There are two types that constitute an XML document and components: <code>Document</code> and <code>Node</code>, respectively. The <code>Document</code> type represents a whole XML document and points to a document node of <code>Node</code> type. The <code>Node</code> type represents almost everything in an XML document, that is, elements, attributes, texts, CDATAs, comments, documents, etc. are all <code>Node</code> type objects.</p><p>Several kinds of constructors are provided to create documents and various node types. For example, <code>XMLDocument</code> creates an XML document, <code>ElementNode</code> does an element node, and <code>TextNode</code> does a text node:</p><pre><code class="language-jlcon">julia&gt; using EzXML

julia&gt; doc = XMLDocument()
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fa2ec190b70&gt;))

julia&gt; typeof(doc)
EzXML.Document

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

julia&gt; elm = ElementNode(&quot;elm&quot;)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fcd5bd42920&gt;)

julia&gt; typeof(elm)
EzXML.Node

julia&gt; println(elm)
&lt;elm/&gt;

julia&gt; txt = TextNode(&quot;some text&quot;)
EzXML.Node(&lt;TEXT_NODE@0x00007fcd5be9aaf0&gt;)

julia&gt; typeof(txt)
EzXML.Node

julia&gt; println(txt)
some text
</code></pre><p>Calling the <code>show</code> method of <code>Node</code> shows a node type and a pointer address to a node struct of libxml2 within the angle brackets so that you can quickly check the type of a node and its identity. The <code>print</code> method of <code>Node</code> shows an XML tree rooted at the node. <code>prettyprint</code> is also provided to print formatted XML.</p><h2><a class="nav-anchor" id="DOM-interfaces-1" href="#DOM-interfaces-1">DOM interfaces</a></h2><p>DOM interfaces regard an XML document as a tree of nodes. There is a root node at the top of a document tree and each node has zero or more child nodes. Some nodes (e.g. texts, attributes, etc.) cannot have child nodes.</p><p>For the demonstration purpose, save the next XML in &quot;primates.xml&quot; file.</p><pre><code class="language-none">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;primates&gt;
    &lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;
    &lt;genus name=&quot;Pan&quot;&gt;
        &lt;species name=&quot;paniscus&quot;&gt;Bonobo&lt;/species&gt;
        &lt;species name=&quot;troglodytes&quot;&gt;Chimpanzee&lt;/species&gt;
    &lt;/genus&gt;
&lt;/primates&gt;</code></pre><p><code>read(Document, &lt;filename&gt;)</code> reads an XML file and builds a document object in memory.  On the other hand <code>parse(Document, &lt;string or byte array&gt;)</code> parses an XML string or a byte array and builds a document object like the <code>read</code> method:</p><pre><code class="language-jlcon">julia&gt; doc = read(Document, &quot;primates.xml&quot;)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fff3cfe8a50&gt;))

julia&gt; data = readstring(&quot;primates.xml&quot;);

julia&gt; doc = parse(Document, data)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fff3d161380&gt;))
</code></pre><p>Before traversing the document we need to retrieve the root of the document tree.  <code>root(&lt;document&gt;)</code> returns the root element of a document and we can start traversal there:</p><pre><code class="language-jlcon">julia&gt; primates = root(doc)  # Get the root element.
EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3d109ef0&gt;)

julia&gt; nodetype(primates)    # The node is an element node.
ELEMENT_NODE

julia&gt; name(primates)        # `name` returns the tag name of an element.
&quot;primates&quot;

julia&gt; haselement(primates)  # Check if a node has one or more elements.
true

julia&gt; genus = elements(primates)  # `elements` returns all child elements.
2-element Array{EzXML.Node,1}:
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)

julia&gt; name.(genus)          # Broadcasting syntax (dot function) works.
2-element Array{String,1}:
 &quot;genus&quot;
 &quot;genus&quot;
</code></pre><p>Attribute values can be accessed by its name like a dictionary; <code>haskey</code>, <code>getindex</code>, <code>setindex!</code> and <code>delete!</code> are overloaded for element nodes. Qualified name, which may or may not have the prefix of a namespace, can be used as a key name:</p><pre><code class="language-jlcon">julia&gt; haskey(genus[1], &quot;name&quot;)  # Check whether an attribute exists.
true

julia&gt; genus[1][&quot;name&quot;]          # Get a value as a string.
&quot;Homo&quot;

julia&gt; genus[2][&quot;name&quot;]          # Same above.
&quot;Pan&quot;

julia&gt; println(genus[1])             # Print a &quot;genus&quot; element before updating.
&lt;genus name=&quot;Homo&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;

julia&gt; genus[1][&quot;taxonID&quot;] = &quot;9206&quot;  # Insert a new attribute.
&quot;9206&quot;

julia&gt; println(genus[1])             # The &quot;genus&quot; element has been updated.
&lt;genus name=&quot;Homo&quot; taxonID=&quot;9206&quot;&gt;
        &lt;species name=&quot;sapiens&quot;&gt;Human&lt;/species&gt;
    &lt;/genus&gt;
</code></pre><p>In this package, a <code>Node</code> object is regarded as a container of its child nodes. This idea is reflected on function names; for example, a function returning the first child node is named as <code>firstnode</code> instead of <code>firstchildnode</code>. All functions provided by the <code>EzXML</code> module are named in this way and tree traversal functions works on its child nodes by default. Functions with a direction prefix works on that direction; for example, <code>nextnode</code> returns the next sibling node and <code>parentnode</code> returns the parent node.</p><p>Distinction between nodes and elements is what every user should know about before using DOM APIs.  There are good explanations on this topic: &lt;http://www.w3schools.com/xml/dom_nodes.asp&gt;, &lt;http://stackoverflow.com/questions/132564/whats-the-difference-between-an-element-and-a-node-in-xml&gt;. Some functions have a suffix like <code>node</code> or <code>element</code> that indicates the node type the function is interested in. For example, <code>hasnode(&lt;parent node&gt;)</code> checks if a (parent) node has one or more child <em>nodes</em> while <code>haselement(&lt;parent node&gt;)</code> checks if a (parent) node has one or more child <em>elements</em>. All functions are also named in this way:</p><pre><code class="language-jlcon">julia&gt; hasnode(primates)       # `primates` contains child nodes?
true

julia&gt; haselement(primates)    # `primates` contains child elements?
true

julia&gt; firstnode(primates)     # Get the first child node, which is a text node.
EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe92f0&gt;)

julia&gt; lastnode(primates)      # Get the last child node, which is a text node, too.
EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe4b60&gt;)

julia&gt; firstelement(primates)  # Get the first child element, which is apparently an element node.
EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)

julia&gt; lastelement(primates)   # Get the last child element, which is apparently an element node, too.
EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)
</code></pre><p>If you&#39;d like to iterate over child nodes or elements, you can use the <code>eachnode(&lt;parent node&gt;)</code> or <code>eachelement(&lt;parent node&gt;)</code> function.  The <code>eachnode</code> function generates all nodes including texts, elements, comments, and so on while <code>eachelement</code> selects element nodes only. <code>nodes(&lt;parent node&gt;)</code> and <code>elements(&lt;parent node&gt;)</code> are handy functions that return a vector of nodes and elements, respectively:</p><pre><code class="language-jlcon">julia&gt; for genus in eachnode(primates)
           @show genus
       end
genus = EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe92f0&gt;)
genus = EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)
genus = EzXML.Node(&lt;TEXT_NODE@0x00007fff3d10a090&gt;)
genus = EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)
genus = EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe4b60&gt;)

julia&gt; for genus in eachelement(primates)
           @show genus
       end
genus = EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)
genus = EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)

julia&gt; nodes(primates)
5-element Array{EzXML.Node,1}:
 EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe92f0&gt;)
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)
 EzXML.Node(&lt;TEXT_NODE@0x00007fff3d10a090&gt;)
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)
 EzXML.Node(&lt;TEXT_NODE@0x00007fff3cfe4b60&gt;)

julia&gt; elements(primates)
2-element Array{EzXML.Node,1}:
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cff0000&gt;)
 EzXML.Node(&lt;ELEMENT_NODE@0x00007fff3cfbdf00&gt;)
</code></pre><p>There are so many functions to traverse XML document trees. The complete list of these functions is available at the reference page.</p><h2><a class="nav-anchor" id="Constructing-documents-1" href="#Constructing-documents-1">Constructing documents</a></h2><p>ExXML.jl also supports constructing XML/HTML documents.</p><p>The components of an XML document can be created using document/node constructors introduced above:</p><pre><code class="language-jlcon">julia&gt; doc = XMLDocument()
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fe4b57bfbc0&gt;))

julia&gt; r = ElementNode(&quot;root&quot;)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b581c5a0&gt;)</code></pre><p>Setting a root element to a document can be done by the <code>setroot!(&lt;document&gt;, &lt;root&gt;)</code> function:</p><pre><code class="language-jlcon">julia&gt; setroot!(doc, r)
EzXML.Document(EzXML.Node(&lt;DOCUMENT_NODE@0x00007fe4b57bfbc0&gt;))

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root/&gt;
</code></pre><p>Other child elements or subtrees can be linked to an existing element using <code>link!(&lt;parent node&gt;, &lt;child node&gt;)</code>:</p><pre><code class="language-jlcon">julia&gt; c = ElementNode(&quot;child&quot;)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b57de820&gt;)

julia&gt; link!(r, c)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b57de820&gt;)

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;&lt;child/&gt;&lt;/root&gt;

julia&gt; setcontent!(c, &quot;some content&quot;)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b57de820&gt;)

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;&lt;child&gt;some content&lt;/child&gt;&lt;/root&gt;

julia&gt; c = ElementNode(&quot;child&quot;)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b5841f00&gt;)

julia&gt; link!(r, c)
EzXML.Node(&lt;ELEMENT_NODE@0x00007fe4b5841f00&gt;)

julia&gt; print(doc)
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;&lt;child&gt;some content&lt;/child&gt;&lt;child/&gt;&lt;/root&gt;
</code></pre><p>After finished building an XML document, the user can serialize it into a file as follows:</p><pre><code class="language-jlcon">julia&gt; write(&quot;out.xml&quot;, doc)  # Write a document into a file.
88

shell&gt; cat out.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root&gt;&lt;child&gt;some content&lt;/child&gt;&lt;child/&gt;&lt;/root&gt;
</code></pre><h2><a class="nav-anchor" id="Streaming-interfaces-1" href="#Streaming-interfaces-1">Streaming interfaces</a></h2><p>In addition to DOM interfaces, EzXML.jl provides a streaming reader of XML files. The streaming reader processes, as the name suggests, a stream of an XML data read from a file instead of reading a whole XML tree into the memory. This enables reading extremely large files that do not fit in RAM.</p><p>Let&#39;s use the following XML file (undirected.graphml) that represents an undirected graph formatted in <a href="http://graphml.graphdrawing.org/">GraphML</a> (slightly simplified for brevity):</p><pre><code class="language-none">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;graphml&gt;
    &lt;graph edgedefault=&quot;undirected&quot;&gt;
        &lt;node id=&quot;n0&quot;/&gt;
        &lt;node id=&quot;n1&quot;/&gt;
        &lt;node id=&quot;n2&quot;/&gt;
        &lt;node id=&quot;n3&quot;/&gt;
        &lt;node id=&quot;n4&quot;/&gt;
        &lt;edge source=&quot;n0&quot; target=&quot;n2&quot;/&gt;
        &lt;edge source=&quot;n1&quot; target=&quot;n2&quot;/&gt;
        &lt;edge source=&quot;n2&quot; target=&quot;n3&quot;/&gt;
        &lt;edge source=&quot;n3&quot; target=&quot;n4&quot;/&gt;
    &lt;/graph&gt;
&lt;/graphml&gt;</code></pre><p>The interfaces of streaming reader are totally different from the DOM interfaces introduced above. The first thing the user needs to do is creating an <code>XMLReader</code> object using the <code>open</code> function:</p><pre><code class="language-jlcon">julia&gt; reader = open(XMLReader, &quot;undirected.graphml&quot;)
EzXML.XMLReader(Ptr{EzXML._TextReader} @0x00007f95fb6c0b00)
</code></pre><p>Iteration is advanced by the <code>done(&lt;reader&gt;)</code> method, which updates the current reading position of the reader and returns <code>false</code> when there is al least one node to read from the stram:</p><pre><code class="language-jlcon">julia&gt; done(reader)  # Read the 1st node.
false

julia&gt; nodetype(reader)
READER_ELEMENT

julia&gt; name(reader)
&quot;graphml&quot;

julia&gt; done(reader)  # Read the 2nd node.
false

julia&gt; nodetype(reader)
READER_SIGNIFICANT_WHITESPACE

julia&gt; name(reader)
&quot;#text&quot;

julia&gt; done(reader)  # Read the 3rd node.
false

julia&gt; nodetype(reader)
READER_ELEMENT

julia&gt; name(reader)
&quot;graph&quot;

julia&gt; reader[&quot;edgedefault&quot;]
&quot;undirected&quot;
</code></pre><p>Unlike DOM interfaces, methods are applied to a reader object. This is because the streaming reader does not construct a DOM tree while reading and hence we have no access to actual nodes of an XML document. Methods like <code>nodetype</code>, <code>name</code>, <code>content</code>, <code>namespace</code> and <code>getindex</code> are overloaded for the reader type.</p><p>An important thing to be noted is that while the value of <code>nodetype</code> for the XML reader returns the current node type, the domain is slightly different from that of <code>nodetype</code> for <code>Node</code>, but slightly different meanings. For example, there are two kinds of values that will be returned when reading an element node: <code>READER_ELEMENT</code> and <code>READER_END_ELEMENT</code>. The former indicates the reader just read an opening tag of an element node while the latter does the reader just read an ending tag of an element node.</p><p>In addition to these functions, there are several functions that are specifict to the streaming reader. The <code>depth(&lt;rreader&gt;)</code> function returns the depth of the current node. The <code>expandtree(&lt;reader&gt;)</code> function expands the current node into a complete subtree rooted at the node. This function is useful when you want to use the DOM interfaces for the node. However, the expanded subtree is alive until the next read of a new node. That means you cannot keep references to (parts of) the expanded subtree.</p><p>An idiomatic way of stream reading would look like this:</p><pre><code class="language-julia">reader = open(Document, &quot;undirected.graphml&quot;)
while !done(reader)
    typ = nodetype(reader)
    # body
end
close(reader)</code></pre><p>Alternatively, EzXML.jl supports <code>for</code> loop, too:</p><pre><code class="language-julia">reader = open(Document, &quot;undirected.graphml&quot;)
for typ in reader
    # body
end
close(reader)</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="references.html"><span class="direction">Next</span><span class="title">References</span></a></footer></article></body></html>
